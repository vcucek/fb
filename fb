#!/bin/bash
# Author: Vito Cucek (vito.cucek@gmail.com)

# Print help
if [[ $1 = "--help" ]]; then
    echo 'File browser'
    echo 'Author: Vito Cucek'
    echo ' '
    echo 'Usage:'
    echo ' fb [-db] [folder]'
    echo ' '
    echo 'Options:'
    echo ' -d : print last folder'
    echo ' -b : show bookmarks'
    echo ' '
    echo 'Enable cd on exit by adding alias to ~/.bashrc file:'
    echo 'alias ff='"'"'fb; cd $(fb -d)'"'"
    echo ' '
    echo 'Movements:'
    echo ' Keys     : 'hjkl' or up, down, left, right arrows'
    echo ' Return   : Open file using xdg-open or enter folder'
    echo ' Backspace: Go back one folder'
    echo ' C^u      : Move up 10 files'
    echo ' C^d      : Move down 10 files'
    echo ' L,M,H    : Move low, middle, high'
    echo ' f[a-z]   : Go to file name starting with'
    echo ' .        : Repeat last "go to" action'
    echo ' '
    echo 'Actions:'
    echo ' q     : Exit script, mode, or dialog'
    echo ' O     : Edit file using default editor or vi'
    echo ' o     : Edit file using default editor or vi in a new terminal window (st by default)'
    echo ' t     : open new terminal window (st by default)'
    echo ' a     : Show hidden files/folders'
    echo ' e     : Execute command using current or marked files'
    echo '         Occurances of {} in specified command will be replaced by marked'
    echo '         files and executed sequentially'
    echo ' /     : Filter display (works also in selection or bookmarks mode)'
    echo ' ?     : Recursive search '
    echo ' g?    : Recursive content search '
    echo ' :     : Open new shell in curent directory and close fb '
    echo ' +     : list current mode (directory,selection,bookmarks,search) keyboard commands '
    echo ' '
    echo 'Bookmarks:'
    echo ' b  : open/close bookmarks '
    echo ' i  : Edit bookmarks (bookmarks mode)'
    echo ' d  : remove file/folder from bookmarks (bookmarks mode)'
    echo ' B  : Add current or marked folders and files to bookmarks '
    echo ' '
    echo 'Select:'
    echo ' v  : mark current file '
    echo ' V  : mark all files in current folder '
    echo ' c  : copy marked files to clipboard as command arguments'
    echo ' y  : add marked files to selection '
    echo ' yy : add current file to selection'
    echo ' x  : clear selection and marked files'
    echo ' '
    echo 'Selection:'
    echo ' s  : show/hide current selection '
    echo ' i  : Edit selection (selection mode)'
    echo ' d  : remove file/folder from selection (selection mode)'
    echo ' x  : clear selection and marked files'
    echo ' '
    echo 'Edit:'
    echo ' n  : create file or folder (to create folder end it with "/")'
    echo ' r  : rename current file or folder'
    echo ' p  : copy selection to current directory'
    echo ' m  : move selection to current directory'
    echo ' d  : delete marked files or folders'
    echo ' '
    echo 'View:'
    echo ' J: Increase height'
    echo ' K: Decrease height'
    echo ' F: Switch to full screen mode'
    exit 0
fi

## Terminal settings ###########################################################

SAVEIFS=""
function terminal_setup {
    # set array separator
    SAVEIFS=$IFS
    FB_IFS=$(echo -en "\n\b")
    IFS=$FB_IFS
    # disable line wrapping
    printf '\e[?7l'
    # hide cursor
    printf '\e[?25l'

    # do not show user input
    stty -echo
}

function terminal_fetch {
    IFS=$' '
    read -r LINES COLUMNS < <(stty size)
    IFS=$FB_IFS
}

function terminal_restore {
    # restore line wrapping
    printf '\e[?7h'
    # show cursor
    printf '\e[?25h'
    # restore array separator
    IFS=$SAVEIFS
    # show user input
    stty echo
}

## Constants ###################################################################
APP_TERM="st"
APP_EDITOR="vim"

# bottom/top padding when scrolling
PADDING=4
# Variable representing visible file system area height
HEIGHT=20
# Start in full screen mode
FULLSCREEN=false

# cache files
cache_dir=${HOME}/.cache/fb
cache_trash=${HOME}/.local/share/Trash
cache_selection=$cache_dir/selection
cache_bookmarks=$cache_dir/bookmarks
cache_cd=$cache_dir/dir

# colors
col_cursor=$'\e[1;31m'
col_select_bg=$'\e[1;103m'
col_select_fg=$'\e[1;30m'
col_nav=$'\e[1;32m'

col_link=$'\e[1;96m'
col_exec=$'\e[1;32m'
col_socket=$'\e[1;95m'
col_char=$'\e[1;93m'
col_folder=$'\e[1;94m'
col_none=$'\e[0m'

## Parameters ##################################################################

show_hidden=false

# Bottom bar text
status_message=""
notification_message=""

# dir,search,bookmarks,selection,marks,action
mode="dir"

# copy,move,delete
action=""

filter=""
search=""

# Draw context variables
fullscreen_mode=$FULLSCREEN

# Variable representing cursor file index
dc_cursor=0
# Variable representing top visible file index
dc_begin=0
# Variable representing number of visible files
dc_height=$HEIGHT
# lines to draw
dc_lines=()
# rendered view
dc_canvas=()

# Current folder variables
dir=$PWD
files=()

last_key=""

cursor_stack=()
bookmarks=()
marks=()

## General Functions ###########################################################

function _read_fb {
    # show user input
    stty echo
    # show cursor
    printf '\e[?25h'
    read $1
    # move one line up
    printf "\e[1A"
    # hide cursor
    printf '\e[?25l'
    # do not show user input
    stty -echo
}

## Cursor stack functions ######################################################

function _cursor_push {
    cursor_stack+=($dc_cursor)
}

function _cursor_pop {
    if [ ${#cursor_stack[@]} -eq 0 ]; then
        dc_cursor=0
    else
        local val=${cursor_stack[-1]}
        unset 'cursor_stack[ ${#cursor_stack[@]}-1 ]'
        dc_cursor=$val
    fi;
}

## Bookmarks functions #########################################################

function _bookmark_add {
    echo "$(echo $1 | cat - $cache_bookmarks)" > $cache_bookmarks
}

function _bookmark_remove {
    unset files[$dc_cursor]
    files=("${files[@]}")
    sed -i "$((dc_cursor + 1))d" $cache_bookmarks
}

## Marks functions #########################################################

function _marks_add {
    marks[dc_cursor]="${files[dc_cursor]}"
}
function _marks_add_all {
    marks=("${files[@]}")
}

function _marks_toggle {
    file_selected=${marks[dc_cursor]}
    # Check if selected
    if [ ! -z "$file_selected" ]; then
        marks[dc_cursor]=
    else
        marks[dc_cursor]="${files[dc_cursor]}"
    fi
}

function _marks_clear {
    marks=()
}

function _marks_args {
    printf "\'%s\' " "${marks[@]}"
}

function _marks_to_selection {
    if [ ${#marks[@]} -ne 0 ]; then
        printf "${marks[*]}" >> $cache_selection
        sed -i "s/ *#.*//g; /^$/d" $cache_selection
    fi
}

## Selection functions #########################################################

function _selection_remove {
    sed -i "$((dc_cursor + 1))d" $cache_selection
    files=($(cat $cache_selection))
}

function _selection_clear {
    > $cache_selection
    files=($(cat $cache_selection))
}

## Setup Content Functions #####################################################

function set_action {
    mode="action"
    action=$1
    status_message=$2
}

function set_bookmarks {
    _marks_clear
    _cursor_push
    dc_cursor=0
    dc_begin=0
    dc_lines=()
    files=($(cat $cache_bookmarks))
    mode="bookmarks"
    status_message="Stored bookmarks: 'q' to quit, '+' to see current mode actions"
}

function set_marks {
    if [ ${#marks[@]} -ne 0 ]; then
        files=("${marks[@]}")
        mode="marks"
        status_message="Marked files: 'q' to quit"
        _marks_clear
    fi
}

function set_selection {
    _marks_clear
    _cursor_push
    dc_cursor=0
    dc_begin=0
    dc_lines=()
    files=($(cat $cache_selection))
    mode="selection"
    status_message="Selection: 'q' to quit, '+' to see current mode actions"
}

function set_filter {
    found=($(printf "${files[*]}" | grep "$1"))
    found_size=${#found[@]}
    if (( found_size > 0)); then
        _cursor_push
        dc_cursor=0
        dc_begin=0
        dc_lines=()
        files=("${found[@]}")
        mode="search"
        status_message="Filter results: 'q' to quit, '+' to see current mode actions"
    else
        notification_message="Nothing found"
    fi
}

function set_search {
    found=($(find $PWD -iname "*$1*" ))
    _cursor_push
    dc_cursor=0
    dc_begin=0
    dc_lines=()
    files=("${found[@]}")
    mode="search"
    status_message="Search results: 'q' to quit, '+' to see current mode actions"
}

function set_search_content {
    found=($(grep -Ir "$1" ))
    _cursor_push
    dc_cursor=0
    dc_begin=0
    dc_lines=("${found[@]}")
    files=($(printf "${found[*]}" | sed "s/ *:.*//"))
    mode="search"
    status_message="Search results: 'q' to quit, '+' to see current mode actions"
}

function set_dir {
    dc_cursor=0
    dc_begin=0
    cd ${1:-.} > /dev/null

    local dir_list=()
    local dir_list_draw=()
    local file_list=()
    local file_list_draw=()

    local tmp=()
    local tmp_details=()

    if $show_hidden; then
        tmp=($(ls -AN -1))
        tmp_details=($(ls -ANlh -1))
    else
        tmp=($(ls -N -1))
        tmp_details=($(ls -Nlh -1))
    fi

    # root directory fix
    [[ $PWD == / ]] && PWD=

    # sort directories first
    for ((i=0; i<${#tmp[*]}; i++)); do
        if [[ -d ${tmp[i]} ]]; then
            dir_list+=("$PWD/${tmp[i]}")
            dir_list_draw+=("${tmp_details[i+1]}")
        else
            file_list+=("$PWD/${tmp[i]}")
            file_list_draw+=("${tmp_details[i+1]}")
        fi
    done

    files=("${dir_list[@]}")
    files+=("${file_list[@]}")
    dc_lines=("${dir_list_draw[@]}")
    dc_lines+=("${file_list_draw[@]}")

    dir=$PWD
    _marks_clear
    mode="dir"
    status_message="Directory mode: 'q' to quit, '+' to see current mode actions"
}

## Rendering Functions #########################################################

function row_nav {
    # store cursor position
    printf "\033[s"
    # move one line down, clear and print
    printf "\033[1B"
    printf "\033[2K"
    printf "%s" "$3$2$1$col_none"
}

function row_nav_end {
    # restore cursor position
    printf "\033[u"
    # set dc_cursor to beginning
    # printf "\e[1A"
    # printf "\e[200D"
}

function row {
    dc_canvas+=("$3$2$1$col_none\033[K")
}

function render {

    dc_canvas=()

    # Clamp rows to terminal height, specified as LINES
    if $fullscreen_mode; then
        dc_height=10000
    fi
    local files_size=${#files[@]}

    dc_height=$(( $dc_height+5 > $LINES ? $LINES-5 : $dc_height ))
    dc_height=$(( $dc_height < $PADDING ? $PADDING : $dc_height ))

    # Clamp cursor
    dc_cursor=$(( $dc_cursor < 0 ? 0 : $dc_cursor ))
    dc_cursor=$(( $dc_cursor > $files_size-1 ? $files_size-1 : $dc_cursor ))

    # Print header and navigation bar
    row "---------------------------------------------------------------------------------------"
    row $PWD $col_nav
    row "---------------------------------------------------------------------------------------"

    dc_begin=$(( $dc_cursor - $dc_begin < $PADDING ? $dc_cursor - $PADDING : $dc_begin ))
    dc_begin=$(( $dc_begin < 0 ? 0 : $dc_begin ))
    dc_begin=$(( $dc_cursor - $dc_begin + $PADDING > $dc_height ? $dc_cursor + $PADDING - $dc_height : $dc_begin ))
    dc_begin=$(( $dc_begin < 0 ? 0 : $dc_begin ))

    for (( i=0; i<$dc_height; i++ )); do
        file_index=$((dc_begin + i))

        file=${files[file_index]}
        file_draw=${dc_lines[file_index]}
        file_marked=${marks[file_index]}

        color_fg=""
        color_bg=""

        # Check if directory
        if [ -d $file ]; then
            color_fg=$col_folder
        # Check if char device
        elif [ -c $file ]; then
            color_fg=$col_char
        # Check if socket
        elif [ -S $file ]; then
            color_fg=$col_socket
        # Check if executable
        elif [ -x $file ]; then
            color_fg=$col_exec
        fi
        # Check if link
        if [ -h $file ]; then
            color_fg=$col_link
        fi

        # Check if selected
        if [ ! -z "$file_marked" ]; then
            color_bg=$col_select_bg
            color_fg=$col_select_fg
        fi
        # Check if current dc_cursor
        if [ $file_index -eq $dc_cursor ]; then
            color_fg=$col_cursor
        fi

        row ${file_draw:-$file} $color_fg $color_bg;
    done

    row "---------------------------------------------------------------------------------------"

    # Print bottom message
    local message=$status_message
    [[ ! -z $notification_message ]] && message=$notification_message
    row $message

    # render all with one print command to improve performance
    printf "%b" "${dc_canvas[*]}"
    # set dc_cursor to beginning
    printf "\e[200D"
    printf "\e[%sA" $(( ${#dc_canvas[@]} - 1 ))
}

function render_clear {
    printf "\e[J"
}

## Init/Exit/Run Functions #################################################

function _initialize() {
    #configure terminal
    terminal_setup
    terminal_fetch

    # initialize cache
    mkdir -p $cache_dir
    touch $cache_selection
    touch $cache_bookmarks

    # register signal hooks
    trap _on_stop TSTP
    trap _on_resume CONT
    trap _on_terminate EXIT
    trap 'terminal_fetch; render' WINCH
}

# Terminal hooks

function _on_terminate(){
    render_clear
    terminal_restore
    printf "%s" "$dir" > $cache_cd
    exit 0
}

function _on_stop(){
    render_clear
    terminal_restore
    kill -s SIGSTOP $$
}

function _on_resume(){
    terminal_setup
    echo Press enter to continue...
}

function _exit(){
    render_clear
    terminal_restore
    printf "%s" "$dir" > $cache_cd
    exit 0
}

function _run {
    render_clear
    echo Executing subshell...
    terminal_restore
    eval '$SHELL'
    terminal_setup
}

function _execute {
    render_clear
    terminal_restore
    if [ ${#marks[@]} -ne 0 ]; then
        eval 'printf "%s\n" "${marks[@]}" | xargs -n 1 -I{} $1'
    else
        eval 'printf "${files[dc_cursor]}" | xargs -n 1 -I{} $1'
    fi
    terminal_setup
}

## Mode actions ############################################################

function _view_keys {
    # resize actions
    if [[ $key = J ]]; then 
        render_clear
        dc_height=$((dc_height + 1))
    fi
    if [[ $key = K ]]; then 
        render_clear
        dc_height=$((dc_height - 1))
    fi
    if [[ $key = F ]]; then 
        if $fullscreen_mode; then
            render_clear
            fullscreen_mode=false
            dc_height=$HEIGHT
        else
            fullscreen_mode=true
        fi
    fi
}

function _action_keys {
    if [[ $key = y ]]; then 
        status_message="Loading..."
        render
        if [[ $action = "copy" ]]; then 
            printf "%s\n" "${files[@]}" | xargs -n 100 -P 0 -I{} cp -r '{}' ./
        fi
        if [[ $action = "move" ]]; then 
            printf "%s\n" "${files[@]}" | xargs -n 100 -P 0 -I{} mv '{}' ./
        fi
        if [[ $action = "delete" ]]; then 
            printf "%s\n" "${files[@]}" | xargs -n 100 -P 0 -I{} rm -r '{}'
        fi
        status_message=""
        _marks_clear
        _selection_clear
        set_dir .
        _cursor_pop
    fi
    if [[ $key = n || $key = q ]]; then 
        status_message=""
        set_dir .
        _cursor_pop
    fi
}

function _navigate_keys {

    if [[ $key = "+" ]]; then
        render_clear
        row_nav
        echo 'Movement commands: '
        echo ' Keys     : 'hjkl' or up, down, left, right arrows'
        echo ' Return   : Open file using xdg-open or enter folder'
        echo ' Backspace: Go back one folder'
        echo ' C^u      : Move up 10 files'
        echo ' C^d      : Move down 10 files'
        echo ' L,M,H    : Move low, middle, high'
        echo ' f[a-z]   : Go to file name starting with'
        echo ' .        : Repeat last "go to" action'
    fi

    # Repeat last go to action
    if [[ $key = . ]]; then 
        last_key="f"
        key=$last_goto_key
    fi
    # Go to action
    if [[ $last_key = f ]]; then 
        last_goto_key=$key
        for (( i=$(( $dc_cursor + 1 )); i<${#files[@]}; i++ )); do
            if [[ "${files[i]##*/}" == "$key"* ]]; then
                dc_cursor=$i
                key="consumed"
                return
            fi
        done
        # if not found go again from beginning
        for (( i=0; i<$dc_cursor; i++ )); do
            if [[ "${files[$i]##*/}" == "$key"* ]]; then
                dc_cursor=$i
                key="consumed"
                return
            fi
        done
        key="consumed"
        return
    fi

    # up/down
    if [[ $key = k || $key = $'\e[A' ]]; then 
        dc_cursor=$((dc_cursor - 1))
    fi
    if [[ $key = j || $key = $'\e[B' ]]; then 
        dc_cursor=$((dc_cursor + 1))
    fi

    # 10 up/down
    if [[ $key = $'\x15' ]]; then
        dc_cursor=$((dc_cursor - 10))
    fi
    if [[ $key = $'\x04' ]]; then
        dc_cursor=$((dc_cursor + 10))
    fi

    # Move high/middle/low
    if [[ $key = H ]]; then
        dc_cursor=$dc_begin
    fi
    if [[ $key = M ]]; then
        dc_cursor=$(( dc_begin + dc_height / 2))
    fi
    if [[ $key = L ]]; then
        dc_cursor=$(( dc_begin + dc_height ))
    fi

    # Move top/bottom
    if [[ $key_l = gg ]]; then
        dc_cursor=0
    fi
    if [[ $key = G ]]; then
        local count=${#dc_lines[@]}
        dc_cursor=$(( count - 1 ))
    fi
}

function _mark_keys {
    if [[ $key = "+" ]]; then
        render_clear
        row_nav
        echo 'Mark and selection commands: '
        echo ' v  : mark current '
        echo ' V  : mark all '
        echo ' c  : copy marked to clipboard as command arguments'
        echo ' y  : add marked to selection '
        echo ' yy : add current to selection'
        echo ' x  : clear selection and marks'
    fi
    # mark all
    if [[ $key = V ]]; then
        _marks_add_all
    fi
    # mark current
    if [[ $key = v  ]]; then
        _marks_toggle 
        dc_cursor=$((dc_cursor + 1))
    fi
    # add marked files to selection
    if [[ $key = y  ]]; then
        _marks_to_selection
        _marks_clear
    fi
    # add current file to selection
    if [[ $key_l = yy  ]]; then
        _marks_clear
        _marks_add
        _marks_store
        _marks_clear
    fi
    # clear marks and selection
    if [[ $key = x  ]]; then
        _marks_clear
        _selection_clear
    fi
    # copy marked to clipboard as command arguments
    if [[ $key = c  ]]; then
        _marks_args | xsel -bi
        _marks_clear
    fi
}

function _search_keys {
    # Print commands
    if [[ $key = "+" ]]; then
        render_clear
        row_nav
        echo 'Search commands: '
        echo ' ?  : Find recursive'
        echo ' g? : Find content recursive'
    fi
    # recursive content search
    if [[ $key_l = 'g?' ]]; then
        local search=
        row_nav "Search content: "; _read_fb search
        [ $search ] && set_search_content $search
        row_nav_end
        key="consumed"
    fi
    # recursive search
    if [[ $key = '?' ]]; then
        local search=
        row_nav "Search: "; _read_fb search
        [ $search ] && set_search $search
        row_nav_end
    fi
}

function _common_keys {
    # Print commands
    if [[ $key = "+" ]]; then
        render_clear
        row_nav
        echo 'General: '
        echo ' O  : Edit file'
        echo ' o  : Edit file in a new window'
        echo ' t  : open new terminal window'
        echo ' e  : Execute command using current or marked files'
        echo ' /  : Filter '
        echo ' :  : Run shell command '
        echo ' b  : open/close bookmarks '
        echo ' B  : bookmark current '
    fi
    # Enter current folder
    if [[ $key = "l" || $key = $'\e[C' || $key = "" ]]; then
        if [ ${#files[@]} -ne 0 ]; then
            local curr="${files[dc_cursor]}"
            if [ -d $curr ]; then
                _cursor_push
                set_dir $curr
            fi
            if [ -h $curr ]; then
                cursor_stack=()
                set_dir $curr
            fi
        fi
    fi
    # Open current file
    if [[ $key = "" ]]; then
        local curr="${files[dc_cursor]}"
        if [ -f $curr ]; then
            xdg-open $curr &>/dev/null &
            disown
        fi
    fi
    # edit current file
    if [[ $key = O ]]; then
        /bin/bash -c "${APP_EDITOR:-vi} \"${files[dc_cursor]}\""
        terminal_setup
    fi
    # edit current file in a new window
    if [[ $key = o ]]; then
        nohup ${APP_TERM:-st} ${APP_EDITOR:-vi} ${files[dc_cursor]} >/dev/null 2>&1 &
    fi
    # open terminal
    if [[ $key = t ]]; then
        nohup ${APP_TERM:-st} >/dev/null 2>&1 &
    fi
    # run program using current file
    if [[ $key = e  ]]; then
        local _program=
        row_nav "execute with: "; _read_fb _program
        [ $_program ] && _execute $_program 
    fi
    # open shell
    if [[ $key = :  ]]; then
        _run
    fi
    # filter
    if [[ $key = /  ]]; then
        row_nav "Filter: "; _read_fb filter
        [ $filter ] && set_filter $filter
        row_nav_end
    fi
    # show bookmarks
    if [[ $key = b  ]]; then
        set_bookmarks
    fi
    # add current dir or marked files to bookmarks
    if [[ $key = B  ]]; then
        if [ ${#marks[@]} -ne 0 ]; then
            for i in "${!marks[@]}"; do
                _bookmark_add "${marks[$i]}"
            done
            _marks_clear
            notification_message="Selection added to bookmarks"
            # bookmark current directory
        else
            _bookmark_add "${files[dc_cursor]}"
            notification_message="Current folder added to bookmarks"
        fi
    fi
    # show selection
    if [[ $key = s  ]]; then
        set_selection
    fi
}

function _search_mode_keys {
    if [[ $key = "+" ]]; then
        render_clear
        row_nav
        echo 'Search mode actions: '
        echo ' d  : delete file or folder '
    fi
    if [[ $key = "l" || $key = $'\e[C' || $key = "" ]]; then
        local curr="${files[dc_cursor]}"
        if [ -d $curr ]; then
            cursor_stack=()
        fi
    fi
    # Command delete selected files
    if [[ $key = d  ]]; then
        if [ ${#marks[@]} -ne 0 ]; then
            set_marks
            set_action "delete" "Delete listed files? (y/n)"
        else
            _marks_add
            set_marks
            set_action "delete" "Delete listed files? (y/n)"
        fi
    fi
}

function _bookmarks_mode_keys {
    if [[ $key = "+" ]]; then
        render_clear
        row_nav
        echo 'Bookmark mode actions: '
        echo ' i  : edit bookmarks '
        echo ' d  : remove bookmark '
    fi
    if [[ $key = i ]]; then
        /bin/bash -c "${APP_EDITOR:-vi} \"$cache_bookmarks\""
        terminal_setup
        set_bookmarks
    fi
    if [[ $key = d ]]; then
        _bookmark_remove
    fi
    if [[ $key = "l" || $key = $'\e[C' || $key = "" ]]; then
        cursor_stack=()
    fi
}

function _selection_mode_keys {
    if [[ $key = "+" ]]; then
        render_clear
        row_nav
        echo 'Selection commands: '
        echo ' i  : edit selection '
        echo ' P  : copy listed files to current folder '
        echo ' M  : move listed files to current folder '
        echo ' D  : delete listed files from filesystem '
    fi
    if [[ $key = i ]]; then
        /bin/bash -c "${APP_EDITOR:-vi} \"$cache_selection\""
        terminal_setup
        set_selection
    fi
    if [[ $key = d  ]]; then
        _selection_remove
    fi
    if [[ $key = P  ]]; then
        set_marks
        set_action "copy" "Copy listed files to current folder (y/n)"
    fi
    if [[ $key = M  ]]; then
        set_marks
        set_action "move" "Move listed files to current folder (y/n)"
    fi
    if [[ $key = D  ]]; then
        set_marks
        set_action "delete" "delete listed files from filesystem (y/n)"
    fi
}

function _dir_mode_keys {
    # Print commands
    if [[ $key = "+" ]]; then
        render_clear
        row_nav
        echo 'Current directory commands: '
        echo ' a  : Show hidden files/folders'
        echo ' n  : create file or folder (to create folder end it with "/")'
        echo ' r  : rename current file or folder'
        echo ' p  : copy selection to current directory'
        echo ' m  : move selection to current directory'
        echo ' d  : delete marked files or folders'
    fi
    # Go back one folder
    if [[ $key = "h" || $key = $'\e[D' || $key = $'\x7f' ]]; then
        set_dir ..
        _cursor_pop
    fi
    # show hiddne files
    if [[ $key = a  ]]; then
        if $show_hidden; then
            show_hidden=false
        else
            show_hidden=true
        fi
        set_dir .
    fi
    # Command create new file
    if [[ $key = n  ]]; then
        row_nav "New file/foler name: "
        _read_fb name
        row_nav_end
        if [[ "$name" == */ ]]; then
            mkdir $name
        else
            touch $name
        fi
        set_dir .
    fi
    # Command paste selection
    if [[ $key = p  ]]; then
        set_selection
        set_action "copy" "Paste listed files? (y/n)"
    fi
    # Command move selection
    if [[ $key = m  ]]; then
        set_selection
        set_action "move" "Move listed files? (y/n)"
    fi
    # Command rename current file
    if [[ $key = r  ]]; then
        _cursor_push
        row_nav "New name: "

        _read_fb name

        terminal_restore
        rename -i "${files[dc_cursor]}" "$name" "${files[dc_cursor]}"
        terminal_setup

        #row_nav_end
        printf "\033[u"
        set_dir .
        _cursor_pop
    fi
    # Command delete selected files
    if [[ $key = d  ]]; then
        if [ ${#marks[@]} -ne 0 ]; then
            set_marks
            set_action "delete" "Delete listed files? (y/n)"
        else
            _marks_add
            set_marks
            set_action "delete" "Delete listed files? (y/n)"
        fi
    fi
}

## Program execution ###########################################################

# Print last directory and exit
if [[ $1 = "-d" ]]; then
    if [ -f $cache_cd ]; then
        echo $(cat $cache_cd)
    fi
    exit 0
fi
# Start program with initial directory
if [[ -d $1 ]]; then
    dir=$1
fi

# Initialize terminal, cache, hooks
_initialize

if [[ $1 = "-b" ]]; then
    # show bookmarks 
    set_bookmarks
else
    # show current directory 
    set_dir $dir
fi

while :
do
    render

    # read key
    k1=
    k2=
    k3=
    read -sn1 k1
    if [[ $k1 == $'\e' ]]; then
        read -sn1 -t 0.0001 k2
        read -sn1 -t 0.0001 k3
    fi
    key=${k1}${k2}${k3}
    key_l=$last_key${k1}${k2}${k3}

    # clear notification message on key press
    notification_message=""

    # handle key actions
    _view_keys

    current_mode=$mode

    if [[ $current_mode = "action" ]]; then
        _navigate_keys
        _action_keys
    elif [[ $current_mode = "selection" ]]; then
        _navigate_keys
        _common_keys
        _mark_keys
        _selection_mode_keys
    elif [[ $current_mode = "search" ]]; then
        _navigate_keys
        _common_keys
        _mark_keys
        _search_keys
        _search_mode_keys
    elif [[ $current_mode = "bookmarks" ]]; then
        _navigate_keys
        _common_keys
        _bookmarks_mode_keys
    fi

    if [[ $current_mode = "dir" ]]; then
        _navigate_keys
        _common_keys
        _mark_keys
        _search_keys
        _dir_mode_keys

        # quit 
        if [[ $key = q || $key = $'\x1b' ]]; then
            _exit
        fi
    else
        # Go to dir mode
        if [[ $key = "h" || $key = $'\e[D' || $key = $'\x7f' ]]; then
            set_dir 
            _cursor_pop
        fi
        if [[ $key = q || $key = $'\x1b' ]]; then
            set_dir
            _cursor_pop
        fi
    fi
    last_key=$key
done

terminal_restore
exit 0
